<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>我的博客 | 心似林往</title><meta name="keywords" content="java"><meta name="author" content="心似林往"><meta name="copyright" content="心似林往"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1笔记1.1堆区 栈区 方法区java里的静态成员变量是放在了堆内存还是栈内存](https:&#x2F;&#x2F;www.cnblogs.com&#x2F;yanduanduan&#x2F;p&#x2F;7150874.html) 转自http:&#x2F;&#x2F;bbs.csdn[.NET](http:&#x2F;&#x2F;lib.csdn.net&#x2F;base&#x2F;dotnet)&#x2F;topics&#x2F;370001490">
<meta property="og:type" content="article">
<meta property="og:title" content="我的博客">
<meta property="og:url" content="http://xinsilinwang.com/2021/05/23/java%E9%87%8C%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E6%98%AF%E6%94%BE%E5%9C%A8%E4%BA%86%E5%A0%86%E5%86%85%E5%AD%98%E8%BF%98%E6%98%AF%E6%A0%88%E5%86%85%E5%AD%98%E7%9A%84%E5%89%AF%E6%9C%AC/index.html">
<meta property="og:site_name" content="心似林往">
<meta property="og:description" content="1笔记1.1堆区 栈区 方法区java里的静态成员变量是放在了堆内存还是栈内存](https:&#x2F;&#x2F;www.cnblogs.com&#x2F;yanduanduan&#x2F;p&#x2F;7150874.html) 转自http:&#x2F;&#x2F;bbs.csdn[.NET](http:&#x2F;&#x2F;lib.csdn.net&#x2F;base&#x2F;dotnet)&#x2F;topics&#x2F;370001490">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://xinsilinwang.com/img/head_sculpture.png">
<meta property="article:published_time" content="2021-05-22T16:16:04.000Z">
<meta property="article:modified_time" content="2021-05-23T05:30:59.025Z">
<meta property="article:author" content="心似林往">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://xinsilinwang.com/img/head_sculpture.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://xinsilinwang.com/2021/05/23/java%E9%87%8C%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E6%98%AF%E6%94%BE%E5%9C%A8%E4%BA%86%E5%A0%86%E5%86%85%E5%AD%98%E8%BF%98%E6%98%AF%E6%A0%88%E5%86%85%E5%AD%98%E7%9A%84%E5%89%AF%E6%9C%AC/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '我的博客',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-05-23 13:30:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="心似林往" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/head_sculpture.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">心似林往</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">我的博客</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-05-22T16:16:04.000Z" title="发表于 2021-05-23 00:16:04">2021-05-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-23T05:30:59.025Z" title="更新于 2021-05-23 13:30:59">2021-05-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="我的博客"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1笔记"><a href="#1笔记" class="headerlink" title="1笔记"></a>1笔记</h1><h2 id="1-1堆区-栈区-方法区"><a href="#1-1堆区-栈区-方法区" class="headerlink" title="1.1堆区 栈区 方法区"></a>1.1堆区 栈区 方法区</h2><p>java里的静态成员变量是放在了堆内存还是栈内存](<a target="_blank" rel="noopener" href="https://www.cnblogs.com/yanduanduan/p/7150874.html">https://www.cnblogs.com/yanduanduan/p/7150874.html</a>)</p>
<p>转自<a href="http://bbs.csdn[.NET](http://lib.csdn.net/base/dotnet)/topics/370001490">http://bbs.csdn[.NET](http://lib.csdn.net/base/dotnet)/topics/370001490</a></p>
<span id="more"></span>

<p>堆区: </p>
<p>1.存储的全部是对象，每个对象都包含一个与之对应的class的信息。(class的目的是得到操作指令)<br>2.jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身<br>栈区:<br>1.每个线程包含一个栈区，栈中只保存基础数据类型的对象和自定义对象的引用(不是对象)，对象都存放在堆区中<br>2.每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。<br>3.栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。<br>方法区:<br>1.又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量。 </p>
<p>2.方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。</p>
<p>程序运行时，我们最好对数据保存到什么地方做到心中有数。特别要注意的是内在的分配，有六个地方都可以保存数据：<br>1、 寄存器。这是最快的保存区域，因为它位于和其他所有保存方式不同的地方：处理器内部。然而，寄存器的数量十分有限，所以寄存器是根据需要由编译器分配。我们对此没有直接的控制权，也不可能在自己的程序里找到寄存器存在的任何踪迹。<br>2、 堆栈。驻留于常规RAM（随机访问存储器）区域。但可通过它的“堆栈指针”获得处理的直接支持。堆栈指针若向下移，会创建新的内存；若向上移，则会释放那些内存。这是一种特别快、特别有效的数据保存方式，仅次于寄存器。创建程序时，<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/java">Java</a>编译器必须准确地知道堆栈内保存的所有数据的“长度”以及“存在时间”。这是由于它必须生成相应的代码，以便向上和向下移动指针。这一限制无疑影响了程序的灵活性，所以尽管有些java数据要保存在堆栈里——特别是对象句柄，但java对象并不放到其中。<br>3、 堆。一种常规用途的内存池（也在RAM区域），其中保存了java对象。和堆栈不同：“内存堆”或“堆”最吸引人的地方在于编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长的时间。因此，用堆保存数据时会得到更大的灵活性。要求创建一个对象时，只需用new命令编制相碰的代码即可。执行这些代码时，会在堆里自动进行数据的保存。当然，为达到这种灵活性，必然会付出一定的代价：在堆里分配存储空间时会花掉更长的时间<br>4、 静态存储。这儿的“静态”是指“位于固定位置”。程序运行期间，静态存储的数据将随时等候调用。可用static关键字指出一个对象的特定元素是静态的。但java对象本身永远都不会置入静态存储空间。<br>5、 常数存储。常数值通常直接置于程序代码内部。这样做是安全的。因为它们永远都不会改变，有的常数需要严格地保护，所以可考虑将它们置入只读存储器（ROM）。<br>6、 非RAM存储。若数据完全独立于一个程序之外，则程序不运行时仍可存在，并在程序的控制范围之外。其中两个最主要的例子便是“流式对象”和“固定对象”。对于流式对象，对象会变成字节流，通常会发给另一台机器，而对于固定对象，对象保存在磁盘中。即使程序中止运行，它们仍可保持自己的状态不变。对于这些类型的数据存储，一个特别有用的技艺就是它们能存在于其他媒体中，一旦需要，甚至能将它们恢复成普通的、基于RAM的对象。</p>
<p>首先，java里面是没有静态变量这个概念的,不信你自己在方法里面定义一个static int i =0；java里只有静态成员变量。它属于类的属性。至于他放在那里？楼上说的是静态区。我不知道到底有没有这个翻译。但是 深入jvm里是是翻译为方法区的。虚拟机的体系结构：堆,方法区，本地方法栈，pc寄存器。而方法区保存的就是一个类的模板，堆是放类的实例的。栈是一般来用来函数计算的。随便找本计算机底层的书都知道了。栈里的数据，函数执行完就不会存储了。这就是为什么局部变量每一次都是一样的。就算给他加一后，下次执行函数的时候还是原来的样子。</p>
<h2 id="1-2数据库三范式"><a href="#1-2数据库三范式" class="headerlink" title="1.2数据库三范式"></a>1.2数据库三范式</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html">数据库设计三大范式</a></p>
<p>为了建立冗余较小、结构合理的数据库，设计数据库时必须遵循一定的规则。在关系型数据库中这种规则就称为范式。范式是符合某一种设计要求的总结。要想设计一个结构合理的关系型数据库，必须满足一定的范式。</p>
<p>​         </p>
<p>在实际开发中最为常见的设计范式有三个：</p>
<p>1．第一范式(确保每列保持原子性)</p>
<p>第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。</p>
<p>第一范式的合理遵循需要根据系统的实际需求来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式，如下表所示。</p>
<p><img src="https://pic002.cnblogs.com/images/2012/270324/2012040114023352.png" alt="img"></p>
<p>上表所示的用户信息遵循了第一范式的要求，这样在对用户使用城市进行分类的时候就非常方便，也提高了数据库的性能。</p>
<p>​         </p>
<p>2．第二范式(确保表中的每列都和主键相关)</p>
<p>第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</p>
<p>比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键，如下表所示。</p>
<p> 订单信息表</p>
<p><img src="https://pic002.cnblogs.com/images/2012/270324/2012040114063976.png" alt="img"></p>
<p>这样就产生一个问题：这个表中是以订单编号和商品编号作为联合主键。这样在该表中商品名称、单位、商品价格等信息不与该表的主键相关，而仅仅是与商品编号相关。所以在这里违反了第二范式的设计原则。</p>
<p>而如果把这个订单信息表进行拆分，把商品信息分离到另一个表中，把订单项目表也分离到另一个表中，就非常完美了。如下所示。</p>
<p><img src="https://pic002.cnblogs.com/images/2012/270324/2012040114082156.png" alt="img"></p>
<p>这样设计，在很大程度上减小了数据库的冗余。如果要获取订单的商品信息，使用商品编号到商品信息表中查询即可。</p>
<p>​         </p>
<p>3．第三范式(确保每列都和主键列直接相关,而不是间接相关)</p>
<p>第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。</p>
<p>比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。如下面这两个表所示的设计就是一个满足第三范式的数据库表。</p>
<p><img src="https://pic002.cnblogs.com/images/2012/270324/2012040114105477.png" alt="img"></p>
<p>这样在查询订单信息的时候，就可以使用客户编号来引用客户信息表中的记录，也不必在订单信息表中多次输入客户信息的内容，减小了数据冗余。</p>
<h2 id="1-3-mysql默认几个库介绍"><a href="#1-3-mysql默认几个库介绍" class="headerlink" title="1.3 mysql默认几个库介绍"></a>1.3 mysql默认几个库介绍</h2><p>2016-12-20 22:57:22 更多</p>
<p>背景介绍：<br> 当我们安装初始化mysql后，默认建了几个数据库，那么这些数据库有什么作用呢？<br>mysql&gt; show databases;<br>+——————–+<br>| Database      |<br>+——————–+<br>| information_schema |<br>| mysql        |<br>| performance_schema |<br>| test        |<br>+——————–+<br>4 rows in set (0.00 sec)</p>
<ol>
<li>  information_schema详细介绍：</li>
</ol>
<p>  information_schema数据库是MySQL自带的，它提供了访问数据库元数据的方式。什么是元数据呢？元数据是关于数据的数据，如数据库名或表名，列的数据类型，或访问权限等。有些时候用于表述该信息的其他术语包括“数据词典”和“系统目录”。<br>在MySQL中，把 information_schema 看作是一个数据库，确切说是信息数据库。其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权 限等。在INFORMATION_SCHEMA中，有数个只读表。它们实际上是视图，而不是基本表，因此，你将无法看到与之相关的任何文件。</p>
<p>information_schema数据库表说明:</p>
<p>SCHEMATA表：提供了当前mysql实例中所有数据库的信息。是show databases的结果取之此表。</p>
<p>TABLES表：提供了关于数据库中的表的信息（包括视图）。详细表述了某个表属于哪个schema，表类型，表引擎，创建时间等信息。是show tables from schemaname的结果取之此表。</p>
<p>COLUMNS表：提供了表中的列信息。详细表述了某张表的所有列以及每个列的信息。是show columns from schemaname.tablename的结果取之此表。</p>
<p>STATISTICS表：提供了关于表索引的信息。是show index from schemaname.tablename的结果取之此表。</p>
<p>USER_PRIVILEGES（用户权限）表：给出了关于全程权限的信息。该信息源自mysql.user授权表。是非标准表。</p>
<p>SCHEMA_PRIVILEGES（方案权限）表：给出了关于方案（数据库）权限的信息。该信息来自mysql.db授权表。是非标准表。</p>
<p>TABLE_PRIVILEGES（表权限）表：给出了关于表权限的信息。该信息源自mysql.tables_priv授权表。是非标准表。</p>
<p>COLUMN_PRIVILEGES（列权限）表：给出了关于列权限的信息。该信息源自mysql.columns_priv授权表。是非标准表。</p>
<p>CHARACTER_SETS（字符集）表：提供了mysql实例可用字符集的信息。是SHOW CHARACTER SET结果集取之此表。</p>
<p>COLLATIONS表：提供了关于各字符集的对照信息。</p>
<p>COLLATION_CHARACTER_SET_APPLICABILITY表：指明了可用于校对的字符集。这些列等效于SHOW COLLATION的前两个显示字段。</p>
<p>TABLE_CONSTRAINTS表：描述了存在约束的表。以及表的约束类型。</p>
<p>KEY_COLUMN_USAGE表：描述了具有约束的键列。</p>
<p>ROUTINES表：提供了关于存储子程序（存储程序和函数）的信息。此时，ROUTINES表不包含自定义函数（UDF）。名为“mysql.proc name”的列指明了对应于INFORMATION_SCHEMA.ROUTINES表的mysql.proc表列。</p>
<p>VIEWS表：给出了关于数据库中的视图的信息。需要有show views权限，否则无法查看视图信息。</p>
<p>TRIGGERS表：提供了关于触发程序的信息。必须有super权限才能查看该表</p>
<ol start="2">
<li>mysql作用介绍：<br>mysql：这个是mysql的核心数据库，类似于sql server中的master表，主要负责存储数据库的用户、权限设置、关键字等mysql自己需要使用的控制和管理信息。不可以删除，如果对mysql不是很了解，也不要轻易修改这个数据库里面的表信息。</li>
</ol>
<ol start="3">
<li> performance_schema作用介绍：</li>
</ol>
<p> mysql 5.5 版本 新增了一个性能优化的引擎： PERFORMANCE_SCHEMA这个功能默认是关闭的：<br>需要设置参数： performance_schema  才可以启动该功能，这个参数是静态参数，只能写在my.cnf 中 不能动态修改。<br>先看看有什么东西吧：<br>mysql&gt; use performance_schema;<br>Database changed<br>mysql&gt; show tables ;<br>+———————————————-+<br>| Tables_in_performance_schema         |<br>+———————————————-+<br>| cond_instances                |<br>| events_waits_current             |<br>| events_waits_history             |<br>| events_waits_history_long           |<br>| events_waits_summary_by_instance       |<br>| events_waits_summary_by_thread_by_event_name |<br>| events_waits_summary_global_by_event_name   |<br>| file_instances                |<br>| file_summary_by_event_name          |<br>| file_summary_by_instance           |<br>| mutex_instances                |<br>| performance_timers              |<br>| rwlock_instances               |<br>| setup_consumers                |<br>| setup_instruments               |<br>| setup_timers                 |<br>| threads                    |<br>+———————————————-+<br>17 rows in set (0.00 sec)</p>
<p>这里的数据表分为几类：</p>
<p>1） setup table ：  设置表，配置监控选项。</p>
<p>2） current events table : 记录当前那些thread 正在发生什么事情。</p>
<p>3） history table  发生的各种事件的历史记录表</p>
<p>4） summary table  对各种事件的统计表</p>
<p>5） 杂项表，乱七八糟表。</p>
<p>setup 表：</p>
<p>mysql&gt; SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES<br>  -&gt; WHERE TABLE_SCHEMA = ‘performance_schema’<br>  -&gt; AND TABLE_NAME LIKE ‘setup%’;<br>+——————-+<br>| TABLE_NAME     |<br>+——————-+<br>| setup_consumers  |<br>| setup_instruments |<br>| setup_timers    |<br>+——————-+</p>
<p>setup_consumers 描述各种事件</p>
<p>setup_instruments 描述这个数据库下的表名以及是否开启监控。</p>
<p>setup_timers  描述 监控选项已经采样频率的时间间隔</p>
<ol start="4">
<li>test作用介绍：<br>这个是安装时候创建的一个测试数据库，和它的名字一样，是一个完全的空数据库，没有任何表，可以删除。</li>
</ol>
<h2 id="1-4-mysql安装"><a href="#1-4-mysql安装" class="headerlink" title="1.4 mysql安装"></a>1.4 mysql安装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.先安装brew</span><br><span class="line"></span><br><span class="line">网址：https://brew.sh/</span><br><span class="line">复制命令：/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br><span class="line">在终端运行</span><br><span class="line">2.brew 安装mysql</span><br><span class="line"></span><br><span class="line">输入命令：brew install mysql@5.7       （可以指定版本安装，不指定版本默认最新版本）复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">3.修改环境变量</span><br><span class="line"></span><br><span class="line">brew安装的东西都是在  </span><br><span class="line"> </span><br><span class="line">/usr/local/Cellar/  </span><br><span class="line"></span><br><span class="line">路径下，所有需要进到里面找到mysql然后一层一层进去直到找到bin目录，获取这时路径</span><br><span class="line"></span><br><span class="line">我的电脑是：</span><br><span class="line"></span><br><span class="line">/usr/local/Cellar/mysql@5.7/5.7.23/bin    （可能mysql版本不同，路径不同，自己切换目录找就ok）</span><br><span class="line"></span><br><span class="line">1）终端输入命令</span><br><span class="line">sudo vim .bash_profile</span><br><span class="line"></span><br><span class="line">2）在文档的最下方输入：</span><br><span class="line"></span><br><span class="line">export PATH=$PATH:/usr/local/Cellar/mysql@5.7/5.7.23/bin</span><br><span class="line"></span><br><span class="line">然后esc退出insert状态，并在最下方输入:wq保存退出。</span><br><span class="line"></span><br><span class="line">3）输入：</span><br><span class="line"></span><br><span class="line">source .bash_profile</span><br><span class="line"></span><br><span class="line">回车执行，运行环境变量。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">4.其他</span><br><span class="line">上面的做法每次关掉终端在打开都需要重新source .bash_profile。于是 vi ~/.zshrc，在这里面添加了：</span><br><span class="line"></span><br><span class="line">export PATH=$&#123;PATH&#125;:/usr/local/Cellar/mysql@5.7/5.7.23/bin</span><br><span class="line"></span><br><span class="line">保存后 source ~/.zshrc </span><br><span class="line"></span><br><span class="line">这样的话就可以一劳永逸了。</span><br><span class="line">https://www.cnblogs.com/xiao-xue-di/p/9655120.html</span><br></pre></td></tr></table></figure>

<h2 id="1-5sql语句优化"><a href="#1-5sql语句优化" class="headerlink" title="1.5sql语句优化"></a>1.5sql语句优化</h2><h3 id="select查询艺术"><a href="#select查询艺术" class="headerlink" title="select查询艺术"></a>select查询艺术</h3><p>1.保证不查询多余的列与行。</p>
<ul>
<li>尽量避免select * 的存在，使用具体的列代替*，避免多余的列</li>
<li>使用where限定具体要查询的数据，避免多余的行</li>
<li>使用top，distinct关键字减少多余重复的行</li>
</ul>
<p>2.慎用distinct关键字</p>
<p>distinct在查询一个字段或者很少字段的情况下使用，会避免重复数据的出现，给查询带来优化效果。</p>
<p>但是查询字段很多的情况下使用，则会大大降低查询效率。</p>
<p><img src="https://images0.cnblogs.com/i/398358/201404/241445112327335.jpg" alt="img"></p>
<p>由这个图，分析下:</p>
<p>很明显带distinct的语句cpu时间和占用时间都高于不带distinct的语句。原因是当查询很多字段时，如果使用distinct，数据库引擎就会对数据进行比较，过滤掉重复数据，然而这个比较，过滤的过程则会毫不客气的占用系统资源，cpu时间。</p>
<p>3.慎用union关键字</p>
<p>此关键字主要功能是把各个查询语句的结果集合并到一个结果集中返回给你。用法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;select 语句1&gt;</span><br><span class="line">union</span><br><span class="line">&lt;select 语句2&gt;</span><br><span class="line">union</span><br><span class="line">&lt;select 语句3&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>满足union的语句必须满足：1.列数相同。 2.对应列数的数据类型要保持兼容。</p>
<p>执行过程：</p>
<p>依次执行select语句–&gt;&gt;合并结果集—&gt;&gt;对结果集进行排序，过滤重复记录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">select * from </span><br><span class="line">(( orde o  left join orderproduct op on o.orderNum=op.orderNum )</span><br><span class="line">inner join product p on op.proNum=p.productnum)  where p.id&lt;10000</span><br><span class="line">union</span><br><span class="line">select * from </span><br><span class="line">(( orde o  left join orderproduct op on o.orderNum=op.orderNum )</span><br><span class="line">inner join product p on op.proNum=p.productnum)  where p.id&lt;20000 and p.id&gt;=10000</span><br><span class="line">union</span><br><span class="line">select * from </span><br><span class="line">(( orde o  left join orderproduct op on o.orderNum=op.orderNum )</span><br><span class="line">inner join product p on op.proNum=p.productnum)  where p.id&gt;20000   ---这里可以写p.id&gt;100 结果一样，因为他筛选过啦</span><br><span class="line"></span><br><span class="line">----------------------------------对比上下两个语句-----------------------------------------</span><br><span class="line">select * from </span><br><span class="line">(( orde o  left join orderproduct op on o.orderNum=op.orderNum )</span><br><span class="line">inner join product p on op.proNum=p.productnum) </span><br></pre></td></tr></table></figure>

<p><img src="https://images0.cnblogs.com/i/398358/201404/241550266231696.jpg" alt="img"></p>
<p>由此可见效率确实低，所以不是在必要情况下避免使用。其实有他执行的第三部：对结果集进行排序，过滤重复记录。就能看出不是什么好鸟。然而不对结果集排序过滤，显然效率是比union高的，那么不排序过滤的关键字有吗？答，有，他是union all，使用union all能对union进行一定的优化。。</p>
<p>4.判断表中是否存在数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from product </span><br><span class="line">select top(1) id from product</span><br></pre></td></tr></table></figure>

<p>很显然下面完胜</p>
<p>5.连接查询的优化</p>
<p>首先你要弄明白你想要的数据是什么样子的，然后再做出决定使用哪一种连接，这很重要。</p>
<p>各种连接的取值大小为：</p>
<ul>
<li>内连接结果集大小取决于左右表满足条件的数量</li>
<li>左连接取决与左表大小，右相反。</li>
<li>完全连接和交叉连接取决与左右两个表的数据总数量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select * from </span><br><span class="line">( (select * from orde where OrderId&gt;10000) o  left join orderproduct op on o.orderNum=op.orderNum )</span><br><span class="line"></span><br><span class="line">select * from </span><br><span class="line">( orde o left join orderproduct op on o.orderNum=op.orderNum )</span><br><span class="line"> where o.OrderId&gt;10000</span><br></pre></td></tr></table></figure>

<p><img src="https://images0.cnblogs.com/i/398358/201404/241616474353548.jpg" alt="img"></p>
<p>由此可见减少连接表的数据数量可以提高效率。</p>
<h3 id="insert插入优化"><a href="#insert插入优化" class="headerlink" title="insert插入优化"></a>insert插入优化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">--创建临时表</span><br><span class="line">create table #tb1</span><br><span class="line">(</span><br><span class="line"> id int,</span><br><span class="line"> name nvarchar(30),</span><br><span class="line"> createTime datetime</span><br><span class="line">)</span><br><span class="line">declare @i int</span><br><span class="line">declare @sql varchar(1000)</span><br><span class="line">set @i=0</span><br><span class="line">while (@i&lt;100000)  --循环插入10w条数据</span><br><span class="line">begin</span><br><span class="line">  set @i=@i+1</span><br><span class="line">  set @sql=&#x27; insert into #tb1 values(&#x27;+convert(varchar(10),@i)+&#x27;,&#x27;&#x27;erzi&#x27;+convert(nvarchar(30),@i)+&#x27;&#x27;&#x27;,&#x27;&#x27;&#x27;+convert(nvarchar(30),getdate())+&#x27;&#x27;&#x27;)&#x27;</span><br><span class="line">  exec(@sql)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>我这里运行时间是51秒</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">--创建临时表</span><br><span class="line">create table #tb2</span><br><span class="line">(</span><br><span class="line"> id int,</span><br><span class="line"> name nvarchar(30),</span><br><span class="line"> createTime datetime</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">declare @i int</span><br><span class="line">declare @sql varchar(8000)</span><br><span class="line">declare @j int</span><br><span class="line">set @i=0</span><br><span class="line">while (@i&lt;10000)  --循环插入10w条数据</span><br><span class="line">begin </span><br><span class="line"> set @j=0</span><br><span class="line"> set @sql=&#x27; insert into #tb2 select &#x27;+convert(varchar(10),@i*100+@j)+&#x27;,&#x27;&#x27;erzi&#x27;+convert(nvarchar(30),@i*100+@j)+&#x27;&#x27;&#x27;,&#x27;&#x27;&#x27;+convert(varchar(50),getdate())+&#x27;&#x27;&#x27;&#x27;</span><br><span class="line"> set @i=@i+1</span><br><span class="line"> while(@j&lt;10)</span><br><span class="line"> begin   </span><br><span class="line">   set @sql=@sql+&#x27; union all select &#x27;+convert(varchar(10),@i*100+@j)+&#x27;,&#x27;&#x27;erzi&#x27;+convert(nvarchar(30),@i*100+@j)+&#x27;&#x27;&#x27;,&#x27;&#x27;&#x27;+convert(varchar(50),getdate())+&#x27;&#x27;&#x27;&#x27;</span><br><span class="line">   set @j=@j+1</span><br><span class="line"> end </span><br><span class="line"> exec(@sql)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">drop table #tb2</span><br><span class="line">select count(1) from #tb2</span><br></pre></td></tr></table></figure>

<p>我这里运行时间大概是20秒</p>
<p>分析说明：insert into select批量插入，明显提升效率。所以以后尽量避免一个个循环插入。</p>
<h3 id="优化修改删除语句"><a href="#优化修改删除语句" class="headerlink" title="优化修改删除语句"></a>优化修改删除语句</h3><p>如果你同时修改或删除过多数据，会造成cpu利用率过高从而影响别人对数据库的访问。</p>
<p>如果你删除或修改过多数据，采用单一循环操作，那么会是效率很低，也就是操作时间过程会很漫长。</p>
<p>这样你该怎么做呢？</p>
<p>折中的办法就是，分批操作数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">delete product where id&lt;1000</span><br><span class="line">delete product where id&gt;=1000 and id&lt;2000</span><br><span class="line">delete product where id&gt;=2000 and id&lt;3000</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>

<p>当然这样的优化方式不一定是最优的选择，其实这三种方式都是可以的，这要根据你系统的访问热度来定夺，关键你要明白什么样的语句是什么样的效果。</p>
<p>总结：优化，最重要的是在于你平时设计语句，数据库的习惯，方式。如果你平时不在意，汇总到一块再做优化，你就需要耐心的分析，然而分析的过程就看你的悟性，需求，知识水平啦。</p>
<h2 id="1-6哈希表（散列表）原理详解"><a href="#1-6哈希表（散列表）原理详解" class="headerlink" title="1.6哈希表（散列表）原理详解"></a>1.6哈希表（散列表）原理详解</h2><p>2018-07-03 19:40:58 更多</p>
<p>版权声明：本文为博主原创文章，遵循<a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接和本声明。本文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/yyyljw/article/details/80903391">https://blog.csdn.net/yyyljw/article/details/80903391</a></p>
<p>什么是哈希表？</p>
<p>哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>
<p>记录的存储位置=f(关键字)</p>
<p>这里的对应关系f称为散列函数，又称为哈希（Hash函数），采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表（Hash table）。</p>
<p>哈希表hashtable(key，value) 就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。（或者：把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。）<br>  而当使用哈希表进行查询的时候，就是再次使用哈希函数将key转换为对应的数组下标，并定位到该空间获取value，如此一来，就可以充分利用到数组的定位性能进行数据定位。</p>
<p>数组的特点是：寻址容易，插入和删除困难；</p>
<p>而链表的特点是：寻址困难，插入和删除容易。</p>
<p>那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？答案是肯定的，这就是我们要提起的哈希表，哈希表有多种不同的实现方法，我接下来解释的是最常用的一种方法——拉链法，我们可以理解为“链表的数组”，如图：</p>
<p><img src="https://img-blog.csdn.net/20160603152626346?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><br>左边很明显是个数组，数组的每个成员包括一个指针，指向一个链表的头，当然这个链表可能为空，也可能元素很多。我们根据元素的一些特征把元素分配到不同的链表中去，也是根据这些特征，找到正确的链表，再从链表中找出这个元素。</p>
<p> Hash的应用</p>
<p>1、Hash主要用于信息安全领域中加密算法，它把一些不同长度的信息转化成杂乱的128位的编码,这些编码值叫做Hash值. 也可以说，Hash就是找到一种数据内容和数据存放地址之间的映射关系</p>
<p>2、查找：哈希表，又称为散列，是一种更加快捷的查找技术。我们之前的查找，都是这样一种思路：集合中拿出来一个元素，看看是否与我们要找的相等，如果不等，缩小范围，继续查找。而哈希表是完全另外一种思路：当我知道key值以后，我就可以直接计算出这个元素在集合中的位置，根本不需要一次又一次的查找</p>
<p>举一个例子，假如我的数组A中，第i个元素里面装的key就是i，那么数字3肯定是在第3个位置，数字10肯定是在第10个位置。哈希表就是利用利用这种基本的思想，建立一个从key到位置的函数，然后进行直接计算查找。</p>
<p>3、Hash表在海量数据处理中有着广泛应用。</p>
<p>Hash Table的查询速度非常的快，几乎是O(1)的时间复杂度。</p>
<p>hash就是找到一种数据内容和数据存放地址之间的映射关系。</p>
<p>散列法：元素特征转变为数组下标的方法。</p>
<p>我想大家都在想一个很严重的问题：“如果两个字符串在哈希表中对应的位置相同怎么办？”,毕竟一个数组容量是有限的，这种可能性很大。解决该问题的方法很多，我首先想到的就是用“链表”。我遇到的很多算法都可以转化成链表来解决，只要在哈希表的每个入口挂一个链表，保存所有对应的字符串就OK了。</p>
<p>散列表的查找步骤 </p>
<p>当存储记录时，通过散列函数计算出记录的散列地址</p>
<p>当查找记录时，我们通过同样的是散列函数计算记录的散列地址，并按此散列地址访问该记录</p>
<p>关键字——散列函数（哈希函数）——散列地址</p>
<p>优点：一对一的查找效率很高；</p>
<p>缺点：一个关键字可能对应多个散列地址；需要查找一个范围时，效果不好。</p>
<p>散列冲突：不同的关键字经过散列函数的计算得到了相同的散列地址。</p>
<p>好的散列函数=计算简单+分布均匀（计算得到的散列地址分布均匀）</p>
<p>哈希表是种数据结构，它可以提供快速的插入操作和查找操作。</p>
<p>优缺点</p>
<p>优点：不论哈希表中有多少数据，查找、插入、删除（有时包括删除）只需要接近常量的时间即0(1）的时间级。实际上，这只需要几条机器指令。</p>
<p>哈希表运算得非常快，在计算机程序中，如果需要在一秒种内查找上千条记录通常使用哈希表（例如拼写检查器)哈希表的速度明显比树快，树的操作通常需要O(N)的时间级。哈希表不仅速度快，编程实现也相对容易。</p>
<p>如果不需要有序遍历数据，并且可以提前预测数据量的大小。那么哈希表在速度和易用性方面是无与伦比的。</p>
<p>缺点：它是基于数组的，数组创建后难于扩展，某些哈希表被基本填满时，性能下降得非常严重，所以程序员必须要清楚表中将要存储多少数据（或者准备好定期地把数据转移到更大的哈希表中，这是个费时的过程）。</p>
<p>  元素特征转变为数组下标的方法就是散列法。散列法当然不止一种，下面列出三种比较常用的：</p>
<p>1，除法散列法<br>最直观的一种，上图使用的就是这种散列法，公式：<br>   index = value % 16<br>学过汇编的都知道，求模数其实是通过一个除法运算得到的，所以叫“除法散列法”。</p>
<p>2，平方散列法<br>求index是非常频繁的操作，而乘法的运算要比除法来得省时（对现在的CPU来说，估计我们感觉不出来），所以我们考虑把除法换成乘法和一个位移操作。公式：<br>   index = (value * value) &gt;&gt; 28  （右移，除以2^28。记法：左移变大，是乘。右移变小，是除。）<br>如果数值分配比较均匀的话这种方法能得到不错的结果，但我上面画的那个图的各个元素的值算出来的index都是0——非常失败。也许你还有个问题，value如果很大，value * value不会溢出吗？答案是会的，但我们这个乘法不关心溢出，因为我们根本不是为了获取相乘结果，而是为了获取index。</p>
<p>3，斐波那契（Fibonacci）散列法</p>
<p>平方散列法的缺点是显而易见的，所以我们能不能找出一个理想的乘数，而不是拿value本身当作乘数呢？答案是肯定的。</p>
<p>1，对于16位整数而言，这个乘数是40503<br>2，对于32位整数而言，这个乘数是2654435769<br>3，对于64位整数而言，这个乘数是11400714819323198485</p>
<p>  这几个“理想乘数”是如何得出来的呢？这跟一个法则有关，叫黄金分割法则，而描述黄金分割法则的最经典表达式无疑就是著名的斐波那契数列，即如此形式的序列：0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233,377, 610， 987, 1597, 2584, 4181, 6765, 10946，…。另外，斐波那契数列的值和太阳系八大行星的轨道半径的比例出奇吻合。</p>
<p>  对我们常见的32位整数而言，公式：<br>  index = (value * 2654435769) &gt;&gt; 28</p>
<p>  如果用这种斐波那契散列法的话，那上面的图就变成这样了：</p>
<p><img src="https://img-blog.csdn.net/20160603152646248?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><br>注：用斐波那契散列法调整之后会比原来的取摸散列法好很多。 </p>
<p>适用范围<br>  快速查找，删除的基本数据结构，通常需要总数据量可以放入内存。</p>
<p>基本原理及要点<br> hash函数选择，针对字符串，整数，排列，具体相应的hash方法。<br>碰撞处理，一种是open hashing，也称为拉链法；另一种就是closed hashing，也称开地址法，opened addressing。</p>
<p> 散列冲突的解决方案：</p>
<p>1.建立一个缓冲区，把凡是拼音重复的人放到缓冲区中。当我通过名字查找人时，发现找的不对，就在缓冲区里找。</p>
<p>2.进行再探测。就是在其他地方查找。探测的方法也可以有很多种。</p>
<p>（1）在找到查找位置的index的index-1，index+1位置查找，index-2，index+2查找，依次类推。这种方法称为线性再探测。</p>
<p>（2）在查找位置index周围随机的查找。称为随机在探测。</p>
<p>（3）再哈希。就是当冲突时，采用另外一种映射方式来查找。</p>
<p>这个程序中是通过取模来模拟查找到重复元素的过程。对待重复元素的方法就是再哈希：对当前key的位置+7。最后，可以通过全局变量来判断需要查找多少次。我这里通过依次查找26个英文字母的小写计算的出了总的查找次数。显然，当总的查找次数/查找的总元素数越接近1时，哈希表更接近于一一映射的函数，查找的效率更高。</p>
<p>扩展<br>  d-left hashing中的d是多个的意思，我们先简化这个问题，看一看2-left hashing。2-left hashing指的是将一个哈希表分成长度相等的两半，分别叫做T1和T2，给T1和T2分别配备一个哈希函数，h1和h2。在存储一个新的key时，同 时用两个哈希函数进行计算，得出两个地址h1[key]和h2[key]。这时需要检查T1中的h1[key]位置和T2中的h2[key]位置，哪一个 位置已经存储的（有碰撞的）key比较多，然后将新key存储在负载少的位置。如果两边一样多，比如两个位置都为空或者都存储了一个key，就把新key 存储在左边的T1子表中，2-left也由此而来。在查找一个key时，必须进行两次hash，同时查找两个位置。</p>
<p>问题实例（海量数据处理）<br>我们知道hash 表在海量数据处理中有着广泛的应用，下面，请看另一道百度面试题：<br>题目：海量日志数据，提取出某日访问百度次数最多的那个IP。<br>方案：IP的数目还是有限的，最多2^32个，所以可以考虑使用hash将ip直接存入内存，然后进行统计。</p>
<h2 id="1-7五大常用算法"><a href="#1-7五大常用算法" class="headerlink" title="1.7五大常用算法"></a>1.7<a target="_blank" rel="noopener" href="https://www.cnblogs.com/pjl1119/p/9034096.html">五大常用算法</a></h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/beyond59241/article/details/50728614">https://blog.csdn.net/beyond59241/article/details/50728614</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/changyuanchn/article/details/51476281">https://blog.csdn.net/changyuanchn/article/details/51476281</a></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>据说有人归纳了计算机的五大常用算法，它们是贪婪算法，动态规划算法，分治算法，回溯算法以及分支限界算法。虽然不知道为何要将这五个算法归为最常用的算法，但是毫无疑问，这五个算法是有很多应用场景的，最优化问题大多可以利用这些算法解决。算法的本质就是解决问题。当数据量比较小时，其实根本就不需要什么算法，写一些for循环完全就可以很快速的搞定了，但是当数据量比较大，场景比较复杂的时候，编写for循环就是一个很不明智的方式了。一是耗时，二是写出的代码绝对是天书。当然还有第三点，这点也是最重要的，写代码是一种艺术，而不是搬砖。前面的文章里对这五种算法都已经做了详细的讲解和归纳，本文主要是一个总结，将这五种算法整理到一起来对比，分析一下。</p>
<h3 id="0）-穷举法"><a href="#0）-穷举法" class="headerlink" title="0） 穷举法"></a>0） 穷举法</h3><p>穷举法简单粗暴，没有什么问题是搞不定的，只要你肯花时间。同时对于小数据量，穷举法就是最优秀的算法。就像太祖长拳，简单，人人都能会，能解决问题，但是与真正的高手过招，就颓了。</p>
<h3 id="1）-贪婪算法"><a href="#1）-贪婪算法" class="headerlink" title="1） 贪婪算法"></a>1） 贪婪算法</h3><p>贪婪算法可以获取到问题的局部最优解，不一定能获取到全局最优解，同时获取最优解的好坏要看贪婪策略的选择。特点就是简单，能获取到局部最优解。就像打狗棍法，同一套棍法，洪七公和鲁有脚的水平就差太多了，因此同样是贪婪算法，不同的贪婪策略会导致得到差异非常大的结果。<br>具体的详细解析请参见下面的文章：<br><a target="_blank" rel="noopener" href="http://blog.csdn.net/changyuanchn/article/details/51417211">http://blog.csdn.net/changyuanchn/article/details/51417211</a></p>
<h3 id="2）-动态规划算法"><a href="#2）-动态规划算法" class="headerlink" title="2） 动态规划算法"></a>2） 动态规划算法</h3><p>当最优化问题具有重复子问题和最优子结构的时候，就是动态规划出场的时候了。动态规划算法的核心就是提供了一个memory来缓存重复子问题的结果，避免了递归的过程中的大量的重复计算。动态规划算法的难点在于怎么将问题转化为能够利用动态规划算法来解决。当重复子问题的数目比较小时，动态规划的效果也会很差。如果问题存在大量的重复子问题的话，那么动态规划对于效率的提高是非常恐怖的。就像斗转星移武功，对手强它也会比较强，对手若，他也会比较弱。<br>具体的详细解析请参见下面的文章：<br><a target="_blank" rel="noopener" href="http://blog.csdn.net/changyuanchn/article/details/51420028">http://blog.csdn.net/changyuanchn/article/details/51420028</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/changyuanchn/article/details/51429979">http://blog.csdn.net/changyuanchn/article/details/51429979</a></p>
<h3 id="3）分治算法"><a href="#3）分治算法" class="headerlink" title="3）分治算法"></a>3）分治算法</h3><p>分治算法的逻辑更简单了，就是一个词，分而治之。分治算法就是把一个大的问题分为若干个子问题，然后在子问题继续向下分，一直到base cases，通过base cases的解决，一步步向上，最终解决最初的大问题。分治算法是递归的典型应用。<br>具体的详细解析请参见下面的文章：<br><a target="_blank" rel="noopener" href="http://blog.csdn.net/changyuanchn/article/details/17150109">http://blog.csdn.net/changyuanchn/article/details/17150109</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/changyuanchn/article/details/51465175">http://blog.csdn.net/changyuanchn/article/details/51465175</a></p>
<h3 id="4）-回溯算法"><a href="#4）-回溯算法" class="headerlink" title="4） 回溯算法"></a>4） 回溯算法</h3><p>回溯算法是深度优先策略的典型应用，回溯算法就是沿着一条路向下走，如果此路不同了，则回溯到上一个<br>分岔路，在选一条路走，一直这样递归下去，直到遍历万所有的路径。八皇后问题是回溯算法的一个经典问题，还有一个经典的应用场景就是迷宫问题。<br>具体的详细解析请参见下面的文章：<br><a target="_blank" rel="noopener" href="http://blog.csdn.net/changyuanchn/article/details/17354461">http://blog.csdn.net/changyuanchn/article/details/17354461</a></p>
<h3 id="5）-分支限界算法"><a href="#5）-分支限界算法" class="headerlink" title="5） 分支限界算法"></a>5） 分支限界算法</h3><p>回溯算法是深度优先，那么分支限界法就是广度优先的一个经典的例子。回溯法一般来说是遍历整个解空间，获取问题的所有解，而分支限界法则是获取一个解（一般来说要获取最优解）。<br>具体的详细解析请参见下面的文章：<br><a target="_blank" rel="noopener" href="http://blog.csdn.net/changyuanchn/article/details/17102037">http://blog.csdn.net/changyuanchn/article/details/17102037</a></p>
<p>分治法</p>
<ul>
<li>基本思想<ul>
<li>将一个问题，分解为多个子问题，递归的去解决子问题，最终合并为问题的解</li>
</ul>
</li>
<li>适用情况<ol>
<li>问题分解为小问题后容易解决</li>
<li>问题可以分解为小问题，即最优子结构</li>
<li>分解后的小问题解可以合并为原问题的解</li>
<li>小问题之间互相独立</li>
</ol>
</li>
<li>实例<ol>
<li>二分查找</li>
<li>快速排序</li>
<li>合并排序</li>
<li>大整数乘法</li>
<li>循环赛日程表</li>
</ol>
</li>
</ul>
<p>动态划分算法</p>
<ul>
<li>基本思想<ul>
<li>将问题分解为多个子问题（阶段），按顺序求解，前一个问题的解为后一个问题提供信息</li>
</ul>
</li>
<li>适用情况<ol>
<li>最优化原理：问题的最优解所包含的子问题的解也是最优的，即最优子结构</li>
<li>无后效性：某个状态一旦确定，就不受以后决策的影响</li>
<li>有重叠子问题</li>
</ol>
</li>
<li>说明<ul>
<li>递推关系是从次小的问题开始到较大问题的转化，往往可以用递归来实现，可以利用之前产生的子问题的解来减少重复的计算</li>
</ul>
</li>
</ul>
<p>回溯法</p>
<ul>
<li>基本思想<ul>
<li>选优搜索法，走不通就退回重选，按照深度优先搜索的策略，从根节点出发，深度搜索解空间</li>
</ul>
</li>
<li>步骤<ul>
<li>确定解空间</li>
<li>确定节点的扩展搜索规则</li>
<li>深度优先方式搜索解空间，用剪枝法避免无效搜索</li>
</ul>
</li>
</ul>
<p>分支界限法</p>
<ul>
<li>基本思想<ul>
<li>与回溯法类似，也是在解空间里搜索解得算法，不同点是，回溯法寻找所有解，分支界限法搜索一个解或者最优解</li>
<li>分支：广度优先策略或者最小耗费（最大效益）优先</li>
<li>分支搜索方式：FIFO、LIFO、优先队列式、分支界限搜索算法</li>
</ul>
</li>
</ul>
<p>贪心算法</p>
<ul>
<li>基本思想<ul>
<li>不从总体最优考虑，仅考虑局部最优解，问题必须具备后无效性</li>
</ul>
</li>
<li>步骤<ul>
<li>将问题分解为多个子问题</li>
<li>得到问题的局部最优解</li>
<li>合并子问题的局部最优解</li>
</ul>
</li>
<li>适用情况<ol>
<li>局部最优策略能导致全局最优解</li>
<li>子问题后无效性</li>
</ol>
</li>
</ul>
<h1 id="1-8-JVM运行原理详解"><a href="#1-8-JVM运行原理详解" class="headerlink" title="1.8 JVM运行原理详解"></a>1.8 JVM运行原理详解</h1><p>2017-05-31 15:01:45 更多</p>
<p>版权声明：本文为博主原创文章，遵循<a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接和本声明。本文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Luomingkui1109/article/details/72820232">https://blog.csdn.net/Luomingkui1109/article/details/72820232</a></p>
<p>1.JVM简析：</p>
<p>   作为一名Java使用者，掌握JVM的体系结构也是很有必要的。</p>
<p>   说起Java，我们首先想到的是Java编程语言，然而事实上，Java是一种技术，它由四方面组成：Java编程语言、Java类文件格式、Java虚拟机和Java应用程序接口(Java API)。它们的关系如下图所示：</p>
<p>   运行期环境代表着Java平台，开发人员编写Java代码(.java文件)，然后将之编译成字节码(.class文件)，再然后字节码被装入内存，一旦字节码进入虚拟机，它就会被解释器解释执行，或者是被即时代码发生器有选择的转换成机器码执行。</p>
<p>   Java平台由Java虚拟机和Java应用程序接口搭建，Java语言则是进入这个平台的通道，用Java语言编写并编译的程序可以运行在这个平台上。这个平台的结构如下图所示：</p>
<p>   在Java平台的结构中, 可以看出Java虚拟机(JVM) 处在核心的位置，是程序与底层操作系统和硬件无关的关键。它的下方是移植接口，移植接口由两部分组成：适配器和Java操作系统, 其中依赖于平台的部分称为适配器；JVM 通过移植接口在具体的平台和操作系统上实现；在JVM 的上方是Java的基本类库和扩展类库以及它们的API， 利用Java API编写的应用程序(application) 和小程序(Java applet) 可以在任何Java平台上运行而无需考虑底层平台, 就是因为有Java虚拟机(JVM)实现了程序与操作系统的分离，从而实现了Java 的平台无关性。</p>
<p>   JVM在它的生存周期中有一个明确的任务，那就是运行Java程序，因此当Java程序启动的时候，就产生JVM的一个实例；当程序运行结束的时候，该实例也跟着消失了。</p>
<p>   下面我们从JVM的基本概念和运过程程这两个方面入手来对它进行深入的研究。</p>
<p>2.JVM基本概念</p>
<p>2.1 基本概念：</p>
<p>   JVM是可运行Java代码的假想计算机 ，包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收，堆 和 一个存储方法域。JVM是运行在操作系统之上的，它与硬件没有直接的交互。</p>
<p>2.2 运行过程：</p>
<p>   我们都知道Java源文件，通过编译器，能够生产相应的.Class文件，也就是字节码文件，而字节码文件又通过Java虚拟机中的解释器，编译成特定机器上的机器码 。</p>
<p>   也就是如下：</p>
<p>   • Java源文件—-&gt;编译器—-&gt;字节码文件</p>
<p>   • 字节码文件—-&gt;JVM—-&gt;机器码</p>
<p>   每一种平台的解释器是不同的，但是实现的虚拟机是相同的，这也就是Java为什么能够跨平台的原因了 ，当一个程序从开始运行，这时虚拟机就开始实例化了，多个程序启动就会存在多个虚拟机实例。程序退出或者关闭，则虚拟机实例消亡，多个虚拟机实例之间数据不能共享。</p>
<p>2.3 三种JVM:</p>
<p>   • Sun公司的HotSpot；</p>
<p>   • BEA公司的JRockit；</p>
<p>   • IBM公司的J9 JVM；</p>
<p>   在JDK1.7及其以前我们所使用的都是Sun公司的HotSpot，但由于Sun公司和BEA公司都被oracle收购，jdk1.8将采用Sun公司的HotSpot和BEA公司的JRockit两个JVM中精华形成jdk1.8的JVM。</p>
<p>3.JVM的体系结构</p>
<p>3.1 Class Loader类加载器</p>
<p>   负责加载 .class文件，class文件在文件开头有特定的文件标示，并且ClassLoader负责class文件的加载等，至于它是否可以运行，则由Execution Engine决定。</p>
<p>3.2 Native Interface本地接口</p>
<p>   本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序，Java诞生的时候C/C++横行的时候，要想立足，必须有调用C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码，它的具体作法是Native Method Stack中登记native方法，在Execution Engine执行时加载native libraies。</p>
<p>   目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机，或者Java系统管理生产设备，在企业级应用中已经比较少见， 因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等。</p>
<p>3.3 Execution Engine 执行引擎</p>
<p>   执行包在装载类的方法中的指令，也就是方法。</p>
<p>3.4 Runtime data area 运行数据区</p>
<p>   虚拟机内存或者Jvm内存，冲整个计算机内存中开辟一块内存存储Jvm需要用到的对象，变量等，运行区数据有分很多小区，分别为：方法区，虚拟机栈，本地方法栈，堆，程序计数器。</p>
<p>\4. Runtime data area 运行数据区详解（栈管运行，堆管存储）：</p>
<p>   说明：JVM调优主要就是优化 Heap堆 和 Method Area 方法区。</p>
<p>4.1 Native Method Stack 本地方法栈</p>
<p>   它的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载native libraies。</p>
<p>4.2 PC Register程序计数器</p>
<p>   每个线程都有一个程序计算器，就是一个指针，指向方法区中的方法字节码（下一个将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。</p>
<p>4.3 Method Area方法区</p>
<p>   方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法如构造函数，接口代码也在此定义。简单说，所有定义的方法的信息都保存在该区域，此区域属于共享区间。</p>
<p>   静态变量，常量，类信息(构造方法/接口定义)，运行时常量池存在方法区中；但是实例变量存在堆内存中，和方法区无关。</p>
<p>4.4 Stack 栈</p>
<p>4.4.1 栈是什么？</p>
<p>   栈也叫栈内存，主管Java程序的运行，是在线程创建时创建，它的生命期是跟随线程的生命期，线程结束栈内存也就释放，对于栈来说不存在垃圾回收问题，只要线程一结束该栈就Over，生命周期和线程一致，是线程私有的。</p>
<p>   基本类型的变量和对象的引用变量都是在函数的栈内存中分配。</p>
<p>4.4.2 栈存储什么？</p>
<p>   栈帧中主要保存3类数据：</p>
<p>​      本地变量（Local Variables）：输入参数和输出参数以及方法内的变量；</p>
<p>​      栈操作（Operand Stack）：记录出栈、入栈的操作；</p>
<p>​      栈帧数据（Frame Data）：包括类文件、方法等等。</p>
<p>4.4.3 栈运行原理</p>
<p>   栈中的数据都是以栈帧（Stack Frame）的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关方法和运行期数据的数据集，当一个方法A被调用时就产生了一个栈帧F1，并被压入到栈中， A方法又调用了B方法，于是产生栈帧F2也被压入栈， B方法又调用了C方法，于是产生栈帧F3也被压入栈…… 依次执行完毕后，先弹出后进……F3栈帧，再弹出F2栈帧，再弹出F1栈帧。</p>
<p>   遵循“先进后出”/“后进先出”原则。</p>
<p>4.5 Heap 堆</p>
<p>   堆这块区域是JVM中最大的，应用的对象和数据都是存在这个区域，这块区域也是线程共享的，也是 gc 主要的回收区，一个 JVM 实例只存在一个堆类存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，以方便执行器执行，堆内存分为三部分：</p>
<p>4.5.1 新生区</p>
<p>   新生区是类的诞生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。新生区又分为两部分：伊甸区（Eden space）和幸存者区（Survivor pace），所有的类都是在伊甸区被new出来的。幸存区有两个：0区（Survivor 0 space）和1区（Survivor 1 space）。当伊甸园的空间用完时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园进行垃圾回收（Minor GC）,将伊甸园中的剩余对象移动到幸存0区。若幸存0区也满了，再对该区进行垃圾回收，然后移动到1区。那如果1去也满了呢？再移动到养老区。若养老区也满了，那么这个时候将产生Major GC（FullGCC），进行养老区的内存清理。若养老区执行Full GC 之后发现依然无法进行对象的保存，就会产生OOM异常“OutOfMemoryError”。</p>
<p>   如果出现java.lang.OutOfMemoryError: Java heap space异常，说明Java虚拟机的堆内存不够。原因有二：</p>
<p>   a.Java虚拟机的堆内存设置不够，可以通过参数-Xms、-Xmx来调整。</p>
<p>   b.代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）。</p>
<p>4.5.2 养老区</p>
<p>​     养老区用于保存从新生区筛选出来的 JAVA 对象，一般池对象都在这个区域活跃。</p>
<p>4.5.3 永久区</p>
<p>​     永久存储区是一个常驻内存区域，用于存放JDK自身所携带的 Class,Interface 的元数据，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭 JVM 才会释放此区域所占用的内存。</p>
<p>   如果出现java.lang.OutOfMemoryError: PermGen space，说明是Java虚拟机对永久代Perm内存设置不够。 原因有二：</p>
<p>   a. 程序启动需要加载大量的第三方jar包。例如：在一个Tomcat下部署了太多的应用。</p>
<p>   b. 大量动态反射生成的类不断被加载，最终导致Perm区被占满。</p>
<p>5.说明</p>
<p>   Jdk1.6及之前：常量池分配在永久代 ；</p>
<p>   Jdk1.7：有，但已经逐步“去永久代” ；</p>
<p>   Jdk1.8及之后：无(java.lang.OutOfMemoryError: PermGen space,这种错误将不会出现在JDK1.8中 )；</p>
<p>5.1 在JDK1.7 中</p>
<p><img src="https://img-blog.csdnimg.cn/20190905115327797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0x1b21pbmdrdWkxMTA5,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>5.2 在JDK 1.8 中</p>
<p><img src="https://img-blog.csdnimg.cn/20190905115327941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0x1b21pbmdrdWkxMTA5,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="1-9-mvc"><a href="#1-9-mvc" class="headerlink" title="1.9 mvc"></a>1.9 mvc</h2><h3 id="Jsp-JavaBean模式，Jsp-Servlet模式，MVC模式介绍"><a href="#Jsp-JavaBean模式，Jsp-Servlet模式，MVC模式介绍" class="headerlink" title="Jsp+JavaBean模式，Jsp+Servlet模式，MVC模式介绍"></a>Jsp+JavaBean模式，Jsp+Servlet模式，MVC模式介绍</h3><p>2019-01-16 22:14:11 更多</p>
<p>版权声明：本文为博主原创文章，遵循<a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接和本声明。本文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/ITBigGod/article/details/86515893">https://blog.csdn.net/ITBigGod/article/details/86515893</a></p>
<h3 id="Jsp-JavaBean模式，Jsp-Servlet模式，MVC模式介绍-1"><a href="#Jsp-JavaBean模式，Jsp-Servlet模式，MVC模式介绍-1" class="headerlink" title="Jsp+JavaBean模式，Jsp+Servlet模式，MVC模式介绍"></a>Jsp+JavaBean模式，Jsp+Servlet模式，MVC模式介绍</h3><p>鉴于最近一些零基础的朋友要做项目，我梳理一下web项目的运行流程，主要是说一下理解思路，有什么不足或不对的，多多理解。</p>
<p>在N久前，传统的项目有用jsp+JavaBeans开发的，有用JSP+Servlet开发的，还有的是符合mvc的JSP+Servlet+JavaBeans开发的。这些说法都没有错。<br>前面两个年代久远，不说了，主要重点说一下，MVC模式。</p>
<h3 id="1-JSP-JavaBean模式："><a href="#1-JSP-JavaBean模式：" class="headerlink" title="1.JSP+JavaBean模式："></a>1.JSP+JavaBean模式：</h3><p>在现在的开发中， JSP+JavaBean模式开发非常之少了,除非你的项目只有芝麻大一点<br>它可以说web开发中的是第一代设计模式，主要是JSP充当视图和控制器，而JavaBeans充当模型。</p>
<p>特点：该模式将业务逻辑与页面表现进行分离，在一定程度上增加了程序的可调试性和维护性。<br>缺点：页面将控制与显示集于一身。<br>结论：简单，适合小型项目的快速构建与运行。</p>
<h3 id="2-JSP-Servlet模式："><a href="#2-JSP-Servlet模式：" class="headerlink" title="2.JSP+Servlet模式："></a>2.JSP+Servlet模式：</h3><p>后来慢慢发展，有人使用jsp+servlet模式来开发。<br>其中就分为：（可能层的定义不这么叫，我忘了具体的。）</p>
<ol>
<li>view层——类比jsp前台交互,比如我们页面显示等，但是jsp中也写了数据交互的东西。JSTL等</li>
<li>web层——类比servlet，它与前台数据进行交互，又和数据库打交道，其次它也动态输出html内。</li>
</ol>
<p>简单的例子</p>
<blockquote>
<p><strong>servlet层中有a方法，实现和数据库交互，jsp将注册信息提交给servlet，在servlet里调用a方法，来接收sp的数据，然后将数据就和数据库关联。</strong></p>
</blockquote>
<h4 id="值得一提的是：Servlet和JSP的一大共同点："><a href="#值得一提的是：Servlet和JSP的一大共同点：" class="headerlink" title="值得一提的是：Servlet和JSP的一大共同点："></a>值得一提的是：Servlet和JSP的一大共同点：</h4><p>Servlet和jsp都可以操作网页：</p>
<p><strong>• Servlet可以在.java文件中通过HttpServletResponse对象动态输出HTML内容，比如out.print()。<br>• JSP在静态HTML/JSP中可以嵌入Java代码，常见JSTL标签&lt;%%&gt;，Java代码被动态执行后生成新的HTML内容。</strong></p>
<p>也就是说，单单只用jsp或者serlvet都可以对网页进行开发，也正是这样，<strong>导致两者它们都有难以维护和杂乱代码的困扰。</strong></p>
<p>所以！扬长避短——MVC(Model-View-Controller)模式非常适合解决这一问题。</p>
<h3 id="3-mvc模式：JSP-Servlet-JavaBean三层架构"><a href="#3-mvc模式：JSP-Servlet-JavaBean三层架构" class="headerlink" title="3.mvc模式：JSP + Servlet + JavaBean三层架构"></a>3.mvc模式：JSP + Servlet + JavaBean三层架构</h3><p>MVC模式（Model-View-Controller），是系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）：<br>可以理解为：JSP充当视图，Servlet充当控制器，JavaBeans充当模型。</p>
<ul>
<li>1.View层（JSP）,前台交互,比如我们注册时的数据等等,serlvet就是与前台数据进行交互的</li>
<li>2.Contrller层（servlet充当）：Model与View之间沟通的桥梁， 这个层有业务处理,用户的注册登录就可以看做是User的业务,我们就需要将相关的处理代码写到这个层中。</li>
<li>3.Model层：实现系统的业务逻辑，即javaBean，常见的就是封装对象的属性、数据库连接操作等。</li>
<li>常规会写一个dao层，是属于mvc里面Model层抽出来。目的就是更单纯的和数据库打交道,将servlet的数据和数据库进行交互。</li>
</ul>
<blockquote>
<p>特点：JSP作为视图，来表现页面；Servlet作为控制器，控制程序的流程并调用业务进行处理；JavaBean封装了业务逻辑。遵循了MVC设计模式<br>缺点：没有统一的开发框架导致开发周期长</p>
</blockquote>
<p>图示：</p>
<p><img src="https://img-blog.csdnimg.cn/20190116214307771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lUQmlnR29k,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>在MVC开发的软件系统中，描述如下所示：<br><img src="https://img-blog.csdnimg.cn/20190116214323845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lUQmlnR29k,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通俗的说，就是web broswer通过view层的jsp页面发出的所有的http请求都应该交给servlet，即控制层来。servlet通过对Javabean，即核心的Model层处理，得到处理结果，然后返回给view层的Jsp页面。Jsp页面返回给浏览器最后的html网页。</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>简单的例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">比如用户的注册业务——addUser()</span><br><span class="line">前台取得注册信息--封装到user对象中,然后调用user的业务，即注册功能控制。</span><br><span class="line">这时就跳到Contrller层,然后此层调用dao中的方法将数据存入数据库。</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<p>在实际应用中可以这样理解：<br>***.JSP,*.html属于视图层，<br>servlet属于控制器层，<br>Class类文件属于javabeans。**</p>
<p>（上层的依赖下层的，servlet是用JAVA写的控制器层。）</p>
<p>对应项目的图示：<br><img src="https://img-blog.csdnimg.cn/20190116214335681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lUQmlnR29k,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这种最经典的mvc模式了。</p>
<p>总结：MVC大体上是jsp+Javabean+Servlet，MVC模式在Web开发中的好处是非常明显，它规避了JSP与Servlet各自的短板，Servlet只负责业务逻辑而不会通过out.append()动态生成HTML代码；JSP中也不会充斥着大量的业务代码，这大大提高了代码的可读性和可维护性。</p>
<h2 id="1-10-耦合"><a href="#1-10-耦合" class="headerlink" title="1.10 耦合"></a>1.10 耦合</h2><p>程序的耦合</p>
<p>​    耦合：程序间的依赖关系</p>
<p>​            包括：类之间的依赖    方法之间的依赖</p>
<p>​    解耦：降低程序间的依赖关系</p>
<p>​            实际开发中：应该做到：编译器不依赖，运行时才依赖</p>
<p>​            解耦的思路：第一步：使用反射来创建对象，而避免使用new关键字</p>
<p>​                                   第二步：通过读取配置文件来获取要创建对象的全限定名</p>
<h2 id="1-11-创建Bean的三种方式"><a href="#1-11-创建Bean的三种方式" class="headerlink" title="1.11 创建Bean的三种方式"></a>1.11 创建Bean的三种方式</h2><p>第一种：使用默认构造函数创建</p>
<p>​                在spring的配置文件中使用bean标签，配以id和class属性之后，且没有其他属性和标签时，采用的就是默认构造函数创建bean对象，此时如果勒种没有默认构造函数，则对象无法创建</p>
<p>第二种：使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入spring容器）</p>
<p>第三种：使用工厂中的静态方法创建对象（使用某个勒种的讲台方法创建对象，并存入spring容器）</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">心似林往</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://xinsilinwang.com/2021/05/23/java%E9%87%8C%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E6%98%AF%E6%94%BE%E5%9C%A8%E4%BA%86%E5%A0%86%E5%86%85%E5%AD%98%E8%BF%98%E6%98%AF%E6%A0%88%E5%86%85%E5%AD%98%E7%9A%84%E5%89%AF%E6%9C%AC/">http://xinsilinwang.com/2021/05/23/java%E9%87%8C%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E6%98%AF%E6%94%BE%E5%9C%A8%E4%BA%86%E5%A0%86%E5%86%85%E5%AD%98%E8%BF%98%E6%98%AF%E6%A0%88%E5%86%85%E5%AD%98%E7%9A%84%E5%89%AF%E6%9C%AC/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://xinsilinwang.com" target="_blank">心似林往</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a></div><div class="post_share"><div class="social-share" data-image="/img/head_sculpture.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2021/05/23/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">我的博客</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">心似林往</div><div class="author-info__description">心似林往</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">1笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1%E5%A0%86%E5%8C%BA-%E6%A0%88%E5%8C%BA-%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">1.1.</span> <span class="toc-text">1.1堆区 栈区 方法区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E8%8C%83%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text">1.2数据库三范式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-mysql%E9%BB%98%E8%AE%A4%E5%87%A0%E4%B8%AA%E5%BA%93%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 mysql默认几个库介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-mysql%E5%AE%89%E8%A3%85"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 mysql安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5sql%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96"><span class="toc-number">1.5.</span> <span class="toc-text">1.5sql语句优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#select%E6%9F%A5%E8%AF%A2%E8%89%BA%E6%9C%AF"><span class="toc-number">1.5.1.</span> <span class="toc-text">select查询艺术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#insert%E6%8F%92%E5%85%A5%E4%BC%98%E5%8C%96"><span class="toc-number">1.5.2.</span> <span class="toc-text">insert插入优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E4%BF%AE%E6%94%B9%E5%88%A0%E9%99%A4%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.5.3.</span> <span class="toc-text">优化修改删除语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%88%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%89%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.6.</span> <span class="toc-text">1.6哈希表（散列表）原理详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95"><span class="toc-number">1.7.</span> <span class="toc-text">1.7五大常用算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.8.</span> <span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0%EF%BC%89-%E7%A9%B7%E4%B8%BE%E6%B3%95"><span class="toc-number">1.8.1.</span> <span class="toc-text">0） 穷举法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89-%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95"><span class="toc-number">1.8.2.</span> <span class="toc-text">1） 贪婪算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95"><span class="toc-number">1.8.3.</span> <span class="toc-text">2） 动态规划算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95"><span class="toc-number">1.8.4.</span> <span class="toc-text">3）分治算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="toc-number">1.8.5.</span> <span class="toc-text">4） 回溯算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%BC%89-%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E7%AE%97%E6%B3%95"><span class="toc-number">1.8.6.</span> <span class="toc-text">5） 分支限界算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-8-JVM%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3"><span class="toc-number">2.</span> <span class="toc-text">1.8 JVM运行原理详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-9-mvc"><span class="toc-number">2.1.</span> <span class="toc-text">1.9 mvc</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Jsp-JavaBean%E6%A8%A1%E5%BC%8F%EF%BC%8CJsp-Servlet%E6%A8%A1%E5%BC%8F%EF%BC%8CMVC%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.1.</span> <span class="toc-text">Jsp+JavaBean模式，Jsp+Servlet模式，MVC模式介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Jsp-JavaBean%E6%A8%A1%E5%BC%8F%EF%BC%8CJsp-Servlet%E6%A8%A1%E5%BC%8F%EF%BC%8CMVC%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">2.1.2.</span> <span class="toc-text">Jsp+JavaBean模式，Jsp+Servlet模式，MVC模式介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-JSP-JavaBean%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="toc-number">2.1.3.</span> <span class="toc-text">1.JSP+JavaBean模式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-JSP-Servlet%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="toc-number">2.1.4.</span> <span class="toc-text">2.JSP+Servlet模式：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%BC%E5%BE%97%E4%B8%80%E6%8F%90%E7%9A%84%E6%98%AF%EF%BC%9AServlet%E5%92%8CJSP%E7%9A%84%E4%B8%80%E5%A4%A7%E5%85%B1%E5%90%8C%E7%82%B9%EF%BC%9A"><span class="toc-number">2.1.4.1.</span> <span class="toc-text">值得一提的是：Servlet和JSP的一大共同点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-mvc%E6%A8%A1%E5%BC%8F%EF%BC%9AJSP-Servlet-JavaBean%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84"><span class="toc-number">2.1.5.</span> <span class="toc-text">3.mvc模式：JSP + Servlet + JavaBean三层架构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-10-%E8%80%A6%E5%90%88"><span class="toc-number">2.2.</span> <span class="toc-text">1.10 耦合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-11-%E5%88%9B%E5%BB%BABean%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">1.11 创建Bean的三种方式</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/05/23/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/" title="我的博客"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="我的博客"/></a><div class="content"><a class="title" href="/2021/05/23/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/" title="我的博客">我的博客</a><time datetime="2021-05-22T16:16:04.000Z" title="发表于 2021-05-23 00:16:04">2021-05-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/23/java%E9%87%8C%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E6%98%AF%E6%94%BE%E5%9C%A8%E4%BA%86%E5%A0%86%E5%86%85%E5%AD%98%E8%BF%98%E6%98%AF%E6%A0%88%E5%86%85%E5%AD%98%E7%9A%84%E5%89%AF%E6%9C%AC/" title="我的博客"><img src="/img/head_sculpture.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="我的博客"/></a><div class="content"><a class="title" href="/2021/05/23/java%E9%87%8C%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E6%98%AF%E6%94%BE%E5%9C%A8%E4%BA%86%E5%A0%86%E5%86%85%E5%AD%98%E8%BF%98%E6%98%AF%E6%A0%88%E5%86%85%E5%AD%98%E7%9A%84%E5%89%AF%E6%9C%AC/" title="我的博客">我的博客</a><time datetime="2021-05-22T16:16:04.000Z" title="发表于 2021-05-23 00:16:04">2021-05-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 心似林往</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>